{"meta":{"title":"Topthinking","subtitle":"","description":"你也许什么都没有错，只是老了","author":"topthinking","url":"https://topthinking.gitee.io","root":"/"},"pages":[{"title":"分类","date":"2017-11-30T16:00:00.000Z","updated":"2020-10-30T15:36:19.310Z","comments":true,"path":"categories/index.html","permalink":"https://topthinking.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"Tagcloud","date":"2017-04-26T09:47:43.000Z","updated":"2020-10-30T15:38:04.882Z","comments":true,"path":"tags/index.html","permalink":"https://topthinking.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-12-16T15:23:30.582Z","updated":"2020-12-16T15:23:30.582Z","comments":true,"path":"about/index.html","permalink":"https://topthinking.gitee.io/about/index.html","excerpt":"","text":"About Me 程序员 Programming Language: web（html、javaScript、CSS） nodejs php go docker python"}],"posts":[{"title":"小知识","slug":"tips","date":"2020-12-16T15:23:30.578Z","updated":"2020-12-16T15:26:16.281Z","comments":true,"path":"2020/12/16/tips/","link":"","permalink":"https://topthinking.gitee.io/2020/12/16/tips/","excerpt":"","text":"记录编程路上的一些盲区知识点，方便后续直接拿来使用 正则 - 不匹配某些单词 /node_modules\\/(?!@babel\\/core)/ /node_modules\\/(?!@babel\\/core\\/)/ 我们可以通过此正则，设置webpack的loader，是否取特定处理某个在node_modules里面的库，对其进行编译 比如，我们需要忽略node_modules，但是除了文件目录node_modules/a/和node_modules/b/，即需要对这两个库，在编译时进行处理，不做忽略 可以设置如下正则：/node_modules\\/(?!a\\/|b\\/)/ nginx配置单页路由 当访问任何一个以test.com/test开头的地址，都会指向/srv/static/test/build/index.html这个文件 解决了在单页应用时，路由跳转，页面刷新出现404的错误情况 123456789server &#123; listen 80; server_name test.com; location ^~ /test &#123; alias /srv/static/test/build/; try_files $uri /test/index.html; &#125;&#125; go语言，整形string转[]byte 给定10,12,13,14,1,2,3 转为 []byte&#123;10,12,13,14,1,2,3&#125; 12345678910111213141516171819202122232425262728293031// 直接看代码package mainimport ( &quot;fmt&quot; &quot;strconv&quot;)const a = `10,12,13,14,1,2,3`func main() &#123; d := []byte&#123;&#125; if len(a) != 0 &#123; lv := &quot;&quot; for _, v := range a &#123; if v == 44 &#123; s, _ := strconv.Atoi(lv) d = append(d, uint8(s)) lv = &quot;&quot; continue &#125; lv = lv + string(v) &#125; s, _ := strconv.Atoi(lv) d = append(d, uint8(s)) &#125; fmt.Println(d)&#125;","categories":[{"name":"开发","slug":"开发","permalink":"https://topthinking.gitee.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://topthinking.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"跨域漫谈","slug":"cross-domain","date":"2020-12-16T15:23:30.577Z","updated":"2020-12-16T15:23:30.577Z","comments":true,"path":"2020/12/16/cross-domain/","link":"","permalink":"https://topthinking.gitee.io/2020/12/16/cross-domain/","excerpt":"","text":"这里主要描述跨域的一些细节 set-cookie 浏览器在请求一个设置session的接口，如果和当前域名不一致，则出现上述这种情况 比如当前浏览器访问地址：http://www.example.com如果请求接口：http://www.test.com/api，那么就会出现上述提示，这种提示就表明了该接口下的cookie没有正常写入，即cookie写入失败 解决方案： - session配置设置如下 1session.Options(sessions.Options&#123;MaxAge: 3600 * 12, Path: &quot;/&quot;, HttpOnly: true, SameSite: http.SameSiteNoneMode, Secure: true&#125;) - 请求接口使用https 即访问地址：https://www.test.com/api，那么cookie就可以正常写入了 但是内部系统，往往没有使用https，如果还需要这种情况进行cookie写入，就可以考虑自动提交form表单 123456789101112// form提交js代码说明const div = document.createElement(&#x27;div&#x27;);div.innerHTML = ` &lt;form id=&quot;login-form&quot; method=&quot;POST&quot; action=&quot;http://www.test.com/api&quot;&gt; &lt;input name=&quot;secret&quot; type=&#x27;hidden&#x27; value=&#x27;$&#123;responseData.data&#125;&#x27;/&gt; &lt;/form&gt;`;document.body.appendChild(div);const run = document.createElement(&#x27;script&#x27;);run.innerHTML = `document.getElementById(&quot;login-form&quot;).submit();`;document.body.appendChild(run); 这样，cookie就正常在www.test.com这个域名下写入了，这个时候别忘了加个回调地址，再重定向回原来访问的页面 已经注入cookie，跨域请求时，cookie协带说明 通常，我们使用fetch函数请求接口，服务端解除跨域限制且支持cookie接收，一般这样设置 前端1234fetch(&quot;http://www.test.com/api/list&quot;, &#123; // 支持携带cookie &quot;credentials&quot;: &quot;include&quot;&#125;); 后端123456789101112131415161718192021// c表示 *gin.Contextmethod := c.Request.Methodorigin := c.Request.Header.Get(&quot;Origin&quot;)if origin != &quot;&quot; &#123; c.Header(&quot;Access-Control-Allow-Origin&quot;, origin) //服务器支持的所有跨域请求的方法 c.Header(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, PUT, DELETE, UPDATE, PATCH&quot;) // 允许跨域设置可以返回其他子段，可以自定义字段 c.Header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,AccessToken,X-CSRF-Token,Authorization,Token,ops_env,ops_version&quot;) // 允许浏览器（客户端）可以解析的头部 （重要） c.Header(&quot;Access-Control-Expose-Headers&quot;, &quot;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type&quot;) // 允许客户端传递校验信息比如 cookie (重要) c.Header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)&#125;//放行所有OPTIONS方法if method == &quot;OPTIONS&quot; &#123; c.AbortWithStatus(http.StatusNoContent)&#125; 但是注意，这个时候，你的cookie并没有带到后端，因为浏览器访问的地址是http://www.example.com，但是请求的接口是http://www.test.com/api/list， 也就说，http://www.test.com/api/这里的cookie写入，肯定是在.test.com这个域名下的，而由于当前访问的域名是.example.com，这个时候cookie就没有办法带过去 只有请求这种地址的跨域是可以的http://api.example.com/list","categories":[{"name":"开发","slug":"开发","permalink":"https://topthinking.gitee.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://topthinking.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"go语言实现递归，扁平转为树形，同时添加层级标识","slug":"go/递归整理树形结构","date":"2020-11-25T13:58:41.790Z","updated":"2020-11-26T01:26:17.147Z","comments":true,"path":"2020/11/25/go/递归整理树形结构/","link":"","permalink":"https://topthinking.gitee.io/2020/11/25/go/%E9%80%92%E5%BD%92%E6%95%B4%E7%90%86%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/","excerpt":"","text":"原始数据结构12345678910111213141516171819202122232425262728293031323334[ &#123; &quot;id&quot;:&quot;1&quot;, &quot;pid&quot;:&quot;0&quot; &#125;, &#123; &quot;id&quot;:&quot;2&quot;, &quot;pid&quot;:&quot;1&quot; &#125;, &#123; &quot;id&quot;:&quot;3&quot;, &quot;pid&quot;:&quot;1&quot; &#125;, &#123; &quot;id&quot;:&quot;4&quot;, &quot;pid&quot;:&quot;0&quot; &#125;, &#123; &quot;id&quot;:&quot;5&quot;, &quot;pid&quot;:&quot;4&quot; &#125;, &#123; &quot;id&quot;:&quot;6&quot;, &quot;pid&quot;:&quot;4&quot; &#125;, &#123; &quot;id&quot;: &quot;7&quot;, &quot;pid&quot;: &quot;3&quot;, &#125;, &#123; &quot;id&quot;: &quot;8&quot;, &quot;pid&quot;: &quot;3&quot;, &#125;,] 目标数据结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[ &#123; &quot;id&quot;:&quot;1&quot;, &quot;pid&quot;:&quot;0&quot;, &quot;level&quot;: 0, &quot;children&quot;:[ &#123; &quot;id&quot;:&quot;2&quot;, &quot;pid&quot;:&quot;1&quot;, &quot;level&quot;: 1, &#125;, &#123; &quot;id&quot;:&quot;3&quot;, &quot;pid&quot;:&quot;1&quot;, &quot;level&quot;: 1, &quot;children&quot;:[ &#123; &quot;id&quot;:&quot;7&quot;, &quot;pid&quot;:&quot;3&quot;, &quot;level&quot;: 2, &#125;, &#123; &quot;id&quot;:&quot;8&quot;, &quot;pid&quot;:&quot;3&quot;, &quot;level&quot;: 2, &#125;, ] &#125;, ] &#125;, &#123; &quot;id&quot;:&quot;4&quot;, &quot;pid&quot;:&quot;0&quot;, &quot;level&quot;: 0, &quot;children&quot;:[ &#123; &quot;id&quot;:&quot;5&quot;, &quot;pid&quot;:&quot;4&quot;, &quot;level&quot;: 1, &#125;, &#123; &quot;id&quot;:&quot;6&quot;, &quot;pid&quot;:&quot;4&quot;, &quot;level&quot;: 1, &#125;, ] &#125;] go实现的核心函数 指定pid根节点和level根层标识 12345678910111213141516func handle(pid string, level int8) []d &#123; var tree []d for _, v := range data &#123; if v.Pid == pid &#123; var children []d children = append(children, handle(v.ID, level+1)...) tree = append(tree, d&#123; Level: level, ID: v.ID, Pid: v.Pid, Children: children, &#125;) &#125; &#125; return tree&#125; 完整代码，粘贴即可运行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package mainimport ( &quot;bytes&quot; &quot;encoding/json&quot; &quot;log&quot; &quot;os&quot;)type dataSource struct &#123; ID string `json:&quot;id&quot;` Pid string `json:&quot;pid&quot;`&#125;type d struct &#123; Level int8 `json:&quot;level&quot;` ID string `json:&quot;id&quot;` Pid string `json:&quot;pid&quot;` Children []d `json:&quot;children&quot;`&#125;var data = []*dataSource&#123; &#123; ID: &quot;1&quot;, Pid: &quot;0&quot;, &#125;, &#123; ID: &quot;2&quot;, Pid: &quot;1&quot;, &#125;, &#123; ID: &quot;3&quot;, Pid: &quot;1&quot;, &#125;, &#123; ID: &quot;4&quot;, Pid: &quot;0&quot;, &#125;, &#123; ID: &quot;5&quot;, Pid: &quot;4&quot;, &#125;, &#123; ID: &quot;6&quot;, Pid: &quot;4&quot;, &#125;, &#123; ID: &quot;7&quot;, Pid: &quot;3&quot;, &#125;, &#123; ID: &quot;8&quot;, Pid: &quot;3&quot;, &#125;,&#125;func handle(pid string, level int8) []d &#123; var tree []d for _, v := range data &#123; if v.Pid == pid &#123; var children []d children = append(children, handle(v.ID, level+1)...) tree = append(tree, d&#123; Level: level, ID: v.ID, Pid: v.Pid, Children: children, &#125;) &#125; &#125; return tree&#125;func main() &#123; root := handle(&quot;0&quot;, 0) b, _ := json.Marshal(root) var out bytes.Buffer err := json.Indent(&amp;out, b, &quot;&quot;, &quot;\\t&quot;) if err != nil &#123; log.Fatalln(err) &#125; out.WriteTo(os.Stdout)&#125; 输出结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[ &#123; &quot;level&quot;: 0, &quot;id&quot;: &quot;1&quot;, &quot;pid&quot;: &quot;0&quot;, &quot;children&quot;: [ &#123; &quot;level&quot;: 1, &quot;id&quot;: &quot;2&quot;, &quot;pid&quot;: &quot;1&quot;, &quot;children&quot;: null &#125;, &#123; &quot;level&quot;: 1, &quot;id&quot;: &quot;3&quot;, &quot;pid&quot;: &quot;1&quot;, &quot;children&quot;: [ &#123; &quot;level&quot;: 2, &quot;id&quot;: &quot;7&quot;, &quot;pid&quot;: &quot;3&quot;, &quot;children&quot;: null &#125;, &#123; &quot;level&quot;: 2, &quot;id&quot;: &quot;8&quot;, &quot;pid&quot;: &quot;3&quot;, &quot;children&quot;: null &#125; ] &#125; ] &#125;, &#123; &quot;level&quot;: 0, &quot;id&quot;: &quot;4&quot;, &quot;pid&quot;: &quot;0&quot;, &quot;children&quot;: [ &#123; &quot;level&quot;: 1, &quot;id&quot;: &quot;5&quot;, &quot;pid&quot;: &quot;4&quot;, &quot;children&quot;: null &#125;, &#123; &quot;level&quot;: 1, &quot;id&quot;: &quot;6&quot;, &quot;pid&quot;: &quot;4&quot;, &quot;children&quot;: null &#125; ] &#125;]","categories":[{"name":"go","slug":"go","permalink":"https://topthinking.gitee.io/categories/go/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://topthinking.gitee.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"递归","slug":"递归","permalink":"https://topthinking.gitee.io/tags/%E9%80%92%E5%BD%92/"},{"name":"算法","slug":"算法","permalink":"https://topthinking.gitee.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"go实现类似Promise.all的功能","slug":"go/promise.all","date":"2020-11-21T15:39:29.618Z","updated":"2020-11-21T15:39:29.619Z","comments":true,"path":"2020/11/21/go/promise.all/","link":"","permalink":"https://topthinking.gitee.io/2020/11/21/go/promise.all/","excerpt":"","text":"主要用来加深对于goroutine和channel的理解吧 什么是Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值 javascript123456789// run1和run2函数都返回promisePromise.all([ run1(), run2()]).then(res=&gt;&#123; // res的数据是个数组 const [run1Res,run2Res] = res; console.log(run1Res,run2Res);&#125;); go 需要用到协程 goroutine和通道 channel 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport ( &quot;fmt&quot; &quot;sort&quot; &quot;time&quot;)func main() &#123; start := time.Now().Unix() out1 := run1(1, 2, 0, -1, 92, 22, 33, 82, 11) out2 := run2(1, 2, 0, -1, 92, 22, 33, 82, 11) res1 := []int&#123;&#125; res2 := []int&#123;&#125; for v := range out1 &#123; res1 = append(res1, v) &#125; for v := range out2 &#123; res2 = append(res2, v) &#125; // 这里的耗时是4秒，而不是6秒 // 即同时执行，多协程抢占式进行任务 fmt.Println(res1, res2) fmt.Println(&quot;耗时：&quot;, time.Now().Unix()-start, &quot; 秒&quot;)&#125;func run1(a ...int) &lt;-chan int &#123; out := make(chan int) go func() &#123; sort.Ints(a) time.Sleep(time.Second * 4) for _, v := range a &#123; out &lt;- v &#125; close(out) &#125;() return out&#125;func run2(a ...int) &lt;-chan int &#123; out := make(chan int) go func() &#123; sort.Ints(a) time.Sleep(time.Second * 2) for _, v := range a &#123; out &lt;- v &#125; close(out) &#125;() return out&#125; 说明 我们可以将每个run的实现封装为promise.New的函数 上述逻辑，可以再使用promise.All的函数实现 GO原生支持异步，用不着promise，这完全是画蛇添足 但是这个主要是想针对多任务并行处理且同时结束的时机控制，加深对于goroutine和channel的理解吧","categories":[{"name":"go","slug":"go","permalink":"https://topthinking.gitee.io/categories/go/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://topthinking.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"dockerfile编写细节","slug":"docker/dockerfile","date":"2020-11-17T14:17:41.419Z","updated":"2020-11-17T15:06:09.103Z","comments":true,"path":"2020/11/17/docker/dockerfile/","link":"","permalink":"https://topthinking.gitee.io/2020/11/17/docker/dockerfile/","excerpt":"","text":"编译 + 部署 通常我们需要在一个指定的目标环境进行代码的编译，比如nodejs12、golang:1.15等环境 那么我们就可以编写 dockerfile 来实现 前提：一个 dockerfile 有且只有一个基础镜像，比如在生产环境运行时，其实不需要大而全的 nodejs 包，只需要一个小而美的即可 12345678910111213141516171819202122232425262728# 使用node:12.19.0镜像编译源代码FROM node:12.19.0 AS buildWORKDIR /codeCOPY . .# 安装依赖，将TS代码编译为ES5代码# 导出到当前目录 distRUN yarnRUN yarn build# 只安装生产环境运行需要的依赖# 比如类似TypeScript、webpack、babel等依赖就不必安装了，减少目标镜像的体积RUN rm -rf node_modulesRUN yarn install --production# 使用最小的node镜像运行node服务FROM node:12.19.0-alpineWORKDIR /code# 拷贝编译后的资源到当前镜像内COPY --from=build /code/dist /code/serverCOPY --from=build /code/node_modules /code/node_modulesCMD [&quot;node&quot;, &quot;server&quot;]","categories":[{"name":"docker","slug":"docker","permalink":"https://topthinking.gitee.io/categories/docker/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://topthinking.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"加密技术漫谈","slug":"secret","date":"2020-11-17T14:13:03.469Z","updated":"2020-11-17T14:14:58.101Z","comments":true,"path":"2020/11/17/secret/","link":"","permalink":"https://topthinking.gitee.io/2020/11/17/secret/","excerpt":"","text":"","categories":[{"name":"安全","slug":"安全","permalink":"https://topthinking.gitee.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://topthinking.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"职业闲谈","slug":"top","date":"2020-08-11T15:48:15.296Z","updated":"2020-11-17T15:08:20.930Z","comments":true,"path":"2020/08/11/top/","link":"","permalink":"https://topthinking.gitee.io/2020/08/11/top/","excerpt":"","text":"硬实力 数据结构和算法（leetcode） 设计模式 前端MDN文档 react源码（diff算法、调度算法等） nodejs底层执行逻辑（v8） 云技术（docker，k8s，serverless） 3D技术（VR、AR） webassembly（go、rust等底层语言） 研究面向5G的商用技术 软实力 思考问题的方式，多场景换位思考 商业价值和技术变现 英语","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://topthinking.gitee.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"职业","slug":"职业","permalink":"https://topthinking.gitee.io/tags/%E8%81%8C%E4%B8%9A/"}]}],"categories":[{"name":"开发","slug":"开发","permalink":"https://topthinking.gitee.io/categories/%E5%BC%80%E5%8F%91/"},{"name":"go","slug":"go","permalink":"https://topthinking.gitee.io/categories/go/"},{"name":"docker","slug":"docker","permalink":"https://topthinking.gitee.io/categories/docker/"},{"name":"安全","slug":"安全","permalink":"https://topthinking.gitee.io/categories/%E5%AE%89%E5%85%A8/"},{"name":"杂谈","slug":"杂谈","permalink":"https://topthinking.gitee.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://topthinking.gitee.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"递归","slug":"递归","permalink":"https://topthinking.gitee.io/tags/%E9%80%92%E5%BD%92/"},{"name":"算法","slug":"算法","permalink":"https://topthinking.gitee.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"职业","slug":"职业","permalink":"https://topthinking.gitee.io/tags/%E8%81%8C%E4%B8%9A/"}]}