{"meta":{"title":"Topthinking","subtitle":"","description":"你也许什么都没有错，只是老了","author":"topthinking","url":"https://topthinking.gitee.io","root":"/"},"pages":[{"title":"关于","date":"2021-02-22T08:23:01.071Z","updated":"2021-02-22T08:23:01.071Z","comments":true,"path":"about/index.html","permalink":"https://topthinking.gitee.io/about/index.html","excerpt":"","text":"About Me 程序员 Programming Language: web（html、javaScript、CSS） nodejs php go docker python Github Issues https://github.com/facebook/jest/issues/11105 https://github.com/babel/babel/issues/12587"},{"title":"分类","date":"2017-11-30T16:00:00.000Z","updated":"2020-10-30T15:36:19.310Z","comments":true,"path":"categories/index.html","permalink":"https://topthinking.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"Tagcloud","date":"2017-04-26T09:47:43.000Z","updated":"2020-10-30T15:38:04.882Z","comments":true,"path":"tags/index.html","permalink":"https://topthinking.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"聊聊electron代码加密","slug":"electron/加密","date":"2021-05-25T15:45:20.487Z","updated":"2021-05-25T16:08:06.127Z","comments":true,"path":"2021/05/25/electron/加密/","link":"","permalink":"https://topthinking.gitee.io/2021/05/25/electron/%E5%8A%A0%E5%AF%86/","excerpt":"","text":"electron技术就是基于开源的chromium内核，实现了跨端的桌面端开发框架，所以其常用的业务开发脚本就是js代码了 那么在打包后，这些js代码虽然会经过压缩混淆编译等处理，但是仍然可以破解出来 所以就需要一种技术，把js代码转成二进制文件 如果可以的话，还需要对这些文件进行加密，绑定本地机器的mac地址，保证了激活唯一性 接下来，将聊聊怎么做这些事情","categories":[{"name":"大前端","slug":"大前端","permalink":"https://topthinking.gitee.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"electron","slug":"electron","permalink":"https://topthinking.gitee.io/tags/electron/"}]},{"title":"代码人生","slug":"my/code-life","date":"2021-05-24T16:16:20.457Z","updated":"2021-05-25T15:58:12.504Z","comments":true,"path":"2021/05/25/my/code-life/","link":"","permalink":"https://topthinking.gitee.io/2021/05/25/my/code-life/","excerpt":"","text":"经过我多年的开发经验，对于所有程序语言的学习，我觉得无非都要经过如下三个阶段 Code （源码）需要对该编程语言的语法、规则、原理了然于心。 熟练编写优雅的功能，深入理解该编程语言在业务使用上的优势和劣势 可以根据实际情况，选择合适的框架和程序来实现功能 能深入该编程语言的底层设计思想，理解该语言创造者的目的，能对该语言或相关框架提出相应的改进建议 Compile（编译）理解编译原理，思考为什么源码需要通过编译 有哪些语言不需要编译即可运行，其存在的优势，以及和编译型语言的对比 深入认识该语言编译前后的代码对比，了解到为什么需要编译器，思考自己如何实现一个编译器 Runtime （运行）清楚的知道，代码在运行时，上下文状态和数据 有哪些公共能力，代码在真正运行时，会遇到哪些问题，怎么去解决和捕获这些问题 以及思考为什么会出现这些问题，看看能否在Code层或者Compile层规避掉 思考：程序运行时，有哪些黑盒，需要去挖掘出这些黑盒的本质，才能提升性能和体验","categories":[{"name":"后花园","slug":"后花园","permalink":"https://topthinking.gitee.io/categories/%E5%90%8E%E8%8A%B1%E5%9B%AD/"}],"tags":[{"name":"工作","slug":"工作","permalink":"https://topthinking.gitee.io/tags/%E5%B7%A5%E4%BD%9C/"}]},{"title":"webpack细节","slug":"webpack","date":"2021-05-24T16:11:39.968Z","updated":"2021-05-25T15:56:02.464Z","comments":true,"path":"2021/05/25/webpack/","link":"","permalink":"https://topthinking.gitee.io/2021/05/25/webpack/","excerpt":"","text":"概念 module、chunk、bundle module：就是 js 的模块化 webpack 支持 CommonJS、ES6 等模块化规范，简单来说就是你通过 import 语句引入的代码 chunk：是 webpack 根据功能拆分出来的，包含三种情况： 你的项目入口（entry） 通过import()动态引入的代码 通过splitChunks拆分出来的代码 chunk 包含 module，可能是一对多，也可能是一对一 bundle：是 webpack 打包之后的各个文件，一般就是和 chunk 是一对一的关系，bundle 就是对 chunk 进行编译压缩打包等处理之后的产物 Webpack 之 SplitChunks 插件用法详解：https://zhuanlan.zhihu.com/p/152097785","categories":[{"name":"大前端","slug":"大前端","permalink":"https://topthinking.gitee.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://topthinking.gitee.io/tags/webpack/"}]},{"title":"在iframe里面使用react-router","slug":"router-in-iframe","date":"2021-05-24T16:11:39.951Z","updated":"2021-05-25T16:09:47.108Z","comments":true,"path":"2021/05/25/router-in-iframe/","link":"","permalink":"https://topthinking.gitee.io/2021/05/25/router-in-iframe/","excerpt":"","text":"说明 iframe 里面嵌入一个基于 HTML5 history 的现代网站，如果需要调用最顶层的浏览器路由（即路由地址体现在地址栏，而不是在 iframe 内的沙箱中） 那么该嵌入的代码就需要添加如下逻辑，去调用父容器的浏览器地址逻辑，这样页面的路由切换也将在浏览器的地址栏有所展示 否则，在 iframe 嵌入单页应用的页面时，在单页路由切换时，浏览器的地址栏不会发生任何变化，会导致页面刷新后，无法正常定位网页内容 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import &#123; history as RouterHistory &#125; from &quot;award-router&quot;;import &#123; createLocation &#125; from &quot;history&quot;;function hasBasename(path, prefix) &#123; return ( path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 &amp;&amp; &quot;/?#&quot;.indexOf(path.charAt(prefix.length)) !== -1 );&#125;function stripBasename(path, prefix) &#123; return hasBasename(path, prefix) ? path.substr(prefix.length) : path;&#125;/** * 路由系统全部交给parent管理 */let parentHistory = window.parent.history;let localReplaceState = history.replaceState;history.pushState = function () &#123; // console.log(&#x27;pushState&#x27;, arguments); if (arguments[0] &amp;&amp; arguments[0].state === &quot;null&quot;) &#123; return; &#125; parentHistory.pushState.apply(parentHistory, arguments); localReplaceState.apply(history, arguments);&#125;;history.replaceState = function () &#123; // console.log(&#x27;replaceState&#x27;, arguments); parentHistory.replaceState.apply(parentHistory, arguments); localReplaceState.apply(history, arguments);&#125;;window.parent.addEventListener(&quot;popstate&quot;, function (e) &#123; // 这里其实路由已经发生变化了，只是react-router的组件没有按照正确的渲染，这里就是要让他进行渲染 let _ref = e.state || &#123;&#125;; let key = _ref.key; let state = _ref.state; let _window$location = window.parent.location; let pathname = _window$location.pathname; let search = _window$location.search; let hash = _window$location.hash; let path = pathname + search + hash; path = stripBasename(path, &quot;/gatekeeper/lego&quot;); const location = createLocation(path, state, key); localReplaceState.apply(history, [ &quot;&quot;, &quot;&quot;, location.pathname + location.search, ]); RouterHistory.push(&#123; pathname: location.pathname, search: location.search, state: &quot;null&quot;, &#125;);&#125;);","categories":[{"name":"大前端","slug":"大前端","permalink":"https://topthinking.gitee.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://topthinking.gitee.io/tags/web/"}]},{"title":"go语言之mongo-db操作","slug":"go/mongo","date":"2021-05-24T16:11:39.940Z","updated":"2021-05-25T15:55:29.797Z","comments":true,"path":"2021/05/25/go/mongo/","link":"","permalink":"https://topthinking.gitee.io/2021/05/25/go/mongo/","excerpt":"","text":"主要罗列出使用 go 语言操作 mongo 的一些细节和注意事项 基于go.mongodb.org/mongo-driver 连接 mongo-db12345678910111213141516171819202122232425262728293031package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;go.mongodb.org/mongo-driver/mongo&quot; &quot;go.mongodb.org/mongo-driver/mongo/options&quot;)// Db mongovar Db *mongo.Clientfunc main() &#123; // 设置客户端连接配置 clientOptions := options.Client().ApplyURI(&quot;mongodb://192.168.41.11:6300&quot;) // 连接到MongoDB client, err := mongo.Connect(context.TODO(), clientOptions) if err != nil &#123; panic(&quot;mongodb创建失败&quot; + err.Error()) &#125; // 检查连接 err = client.Ping(context.TODO(), nil) if err != nil &#123; panic(&quot;mongodb连接失败&quot; + err.Error()) &#125; Db = client&#125; #","categories":[{"name":"服务端","slug":"服务端","permalink":"https://topthinking.gitee.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"tags":[{"name":"go","slug":"go","permalink":"https://topthinking.gitee.io/tags/go/"},{"name":"mongo","slug":"mongo","permalink":"https://topthinking.gitee.io/tags/mongo/"}]},{"title":"基金净值期望计算公式","slug":"my/fund","date":"2021-05-24T16:11:39.938Z","updated":"2021-05-25T15:58:04.552Z","comments":true,"path":"2021/05/25/my/fund/","link":"","permalink":"https://topthinking.gitee.io/2021/05/25/my/fund/","excerpt":"","text":"\\gamma = \\frac{∆\\alpha}{∆\\beta} -1 $\\gamma$ 购买力期望系数 $∆\\alpha$ 已经购买的净值 $-$ 当天收盘净值 $∆\\beta$ 期望达到的净值 $-$ 当天收盘净值 N = \\gamma * M $N$ 购买的份额数 $M$ 已购买的基金份额 C = N * p $C$ 需要投入的资金 $p$ 购买时当天收盘净值 当$lim_{∆\\beta \\to 0}$时，$N$的值将趋于$\\infty$，$C$ 也将趋于$\\infty$ 当$lim{\\frac{∆\\alpha}{∆\\beta}\\to 1}$时，$lim{\\gamma \\to 0}$，$C$ 将趋于 $0$ ✅ 坚持低位定投，当$C$为负数时，将开始获得收益","categories":[{"name":"后花园","slug":"后花园","permalink":"https://topthinking.gitee.io/categories/%E5%90%8E%E8%8A%B1%E5%9B%AD/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://topthinking.gitee.io/tags/%E6%8A%95%E8%B5%84/"}]},{"title":"dockerfile编写细节","slug":"docker/dockerfile-file","date":"2021-05-24T16:11:39.935Z","updated":"2021-05-25T15:55:00.524Z","comments":true,"path":"2021/05/25/docker/dockerfile-file/","link":"","permalink":"https://topthinking.gitee.io/2021/05/25/docker/dockerfile-file/","excerpt":"","text":"编译 + 部署 通常我们需要在一个指定的目标环境进行代码的编译，比如nodejs12、golang:1.15等环境 那么我们就可以编写 dockerfile 来实现 前提：一个 dockerfile 有且只有一个基础镜像，比如在生产环境运行时，其实不需要大而全的 nodejs 包，只需要一个小而美的即可 12345678910111213141516171819202122232425262728# 使用node:12.19.0镜像编译源代码FROM node:12.19.0 AS buildWORKDIR /codeCOPY . .# 安装依赖，将TS代码编译为ES5代码# 导出到当前目录 distRUN yarnRUN yarn build# 只安装生产环境运行需要的依赖# 比如类似TypeScript、webpack、babel等依赖就不必安装了，减少目标镜像的体积RUN rm -rf node_modulesRUN yarn install --production# 使用最小的node镜像运行node服务FROM node:12.19.0-alpineWORKDIR /code# 拷贝编译后的资源到当前镜像内COPY --from=build /code/dist /code/serverCOPY --from=build /code/node_modules /code/node_modulesCMD [&quot;node&quot;, &quot;server&quot;]","categories":[{"name":"服务端","slug":"服务端","permalink":"https://topthinking.gitee.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://topthinking.gitee.io/tags/docker/"}]},{"title":"小知识","slug":"tips","date":"2020-12-16T15:23:30.578Z","updated":"2021-05-25T15:57:07.551Z","comments":true,"path":"2020/12/16/tips/","link":"","permalink":"https://topthinking.gitee.io/2020/12/16/tips/","excerpt":"","text":"记录编程路上的一些盲区知识点，方便后续直接拿来使用 正则 - 不匹配某些单词 /node_modules\\/(?!@babel\\/core)/ /node_modules\\/(?!@babel\\/core\\/)/ 我们可以通过此正则，设置 webpack 的 loader，是否取特定处理某个在 node_modules 里面的库，对其进行编译 比如，我们需要忽略 node_modules，但是除了文件目录node_modules/a/和node_modules/b/，即需要对这两个库，在编译时进行处理，不做忽略 可以设置如下正则：/node_modules\\/(?!a\\/|b\\/)/ nginx 配置单页路由 当访问任何一个以test.com/test开头的地址，都会指向/srv/static/test/build/index.html这个文件 解决了在单页应用时，路由跳转，页面刷新出现 404 的错误情况 123456789server &#123; listen 80; server_name test.com; location ^~ /test &#123; alias /srv/static/test/build/; try_files $uri /test/index.html; &#125;&#125; go 语言，整形 string 转[]byte 给定10,12,13,14,1,2,3 转为 []byte&#123;10,12,13,14,1,2,3&#125; 12345678910111213141516171819202122232425262728293031// 直接看代码package mainimport ( &quot;fmt&quot; &quot;strconv&quot;)const a = `10,12,13,14,1,2,3`func main() &#123; d := []byte&#123;&#125; if len(a) != 0 &#123; lv := &quot;&quot; for _, v := range a &#123; if v == 44 &#123; s, _ := strconv.Atoi(lv) d = append(d, uint8(s)) lv = &quot;&quot; continue &#125; lv = lv + string(v) &#125; s, _ := strconv.Atoi(lv) d = append(d, uint8(s)) &#125; fmt.Println(d)&#125; 部署 pgadmin1docker run --name pgadmin -p 5080:80 -e &#x27;PGADMIN_DEFAULT_EMAIL=topthinking@test.com&#x27; -e &#x27;PGADMIN_DEFAULT_PASSWORD=123456&#x27; -e &#x27;PGADMIN_CONFIG_ENHANCED_COOKIE_PROTECTION=True&#x27; -e &#x27;PGADMIN_CONFIG_LOGIN_BANNER=&quot;Authorised users only!&quot;&#x27; -e &#x27;PGADMIN_CONFIG_CONSOLE_LOG_LEVEL=10&#x27; -d dpage/pgadmin4:latest docker 镜像加速 下载安装 docker 服务 https://hub.docker.com/editions/community/docker-ce-desktop-mac 阿里容器镜像加速，需要登录阿里账户 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 正则匹配所有字符串（包括换行）1const match = content.match(/&lt;body&gt;([\\d\\D]*)&lt;\\/body&gt;/);","categories":[{"name":"通用技术","slug":"通用技术","permalink":"https://topthinking.gitee.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://topthinking.gitee.io/tags/tips/"}]},{"title":"跨域漫谈","slug":"cross-domain","date":"2020-12-16T15:23:30.577Z","updated":"2021-05-25T15:54:00.457Z","comments":true,"path":"2020/12/16/cross-domain/","link":"","permalink":"https://topthinking.gitee.io/2020/12/16/cross-domain/","excerpt":"","text":"这里主要描述跨域的一些细节 set-cookie 浏览器在请求一个设置 session 的接口，如果和当前域名不一致，则出现上述这种情况 比如当前浏览器访问地址：http://www.example.com如果请求接口：http://www.test.com/api，那么就会出现上述提示，这种提示就表明了该接口下的 cookie 没有正常写入，即 cookie 写入失败 解决方案： - session 配置设置如下go session.Options(sessions.Options&#123;MaxAge: 3600 * 12, Path: &quot;/&quot;, HttpOnly: true, SameSite: http.SameSiteNoneMode, Secure: true&#125;) - 请求接口使用https即访问地址：https://www.test.com/api，那么 cookie 就可以正常写入了 但是内部系统，往往没有使用 https，如果还需要这种情况进行 cookie 写入，就可以考虑自动提交 form 表单 123456789101112// form提交js代码说明const div = document.createElement(&quot;div&quot;);div.innerHTML = ` &lt;form id=&quot;login-form&quot; method=&quot;POST&quot; action=&quot;http://www.test.com/api&quot;&gt; &lt;input name=&quot;secret&quot; type=&#x27;hidden&#x27; value=&#x27;$&#123;responseData.data&#125;&#x27;/&gt; &lt;/form&gt;`;document.body.appendChild(div);const run = document.createElement(&quot;script&quot;);run.innerHTML = `document.getElementById(&quot;login-form&quot;).submit();`;document.body.appendChild(run); 这样，cookie 就正常在www.test.com这个域名下写入了，这个时候别忘了加个回调地址，再重定向回原来访问的页面 已经注入 cookie，跨域请求时，cookie 协带说明 通常，我们使用 fetch 函数请求接口，服务端解除跨域限制且支持 cookie 接收，一般这样设置 前端1234fetch(&quot;http://www.test.com/api/list&quot;, &#123; // 支持携带cookie credentials: &quot;include&quot;,&#125;); 后端123456789101112131415161718192021// c表示 *gin.Contextmethod := c.Request.Methodorigin := c.Request.Header.Get(&quot;Origin&quot;)if origin != &quot;&quot; &#123; c.Header(&quot;Access-Control-Allow-Origin&quot;, origin) //服务器支持的所有跨域请求的方法 c.Header(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, PUT, DELETE, UPDATE, PATCH&quot;) // 允许跨域设置可以返回其他子段，可以自定义字段 c.Header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,AccessToken,X-CSRF-Token,Authorization,Token,ops_env,ops_version&quot;) // 允许浏览器（客户端）可以解析的头部 （重要） c.Header(&quot;Access-Control-Expose-Headers&quot;, &quot;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type&quot;) // 允许客户端传递校验信息比如 cookie (重要) c.Header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)&#125;//放行所有OPTIONS方法if method == &quot;OPTIONS&quot; &#123; c.AbortWithStatus(http.StatusNoContent)&#125; 但是注意，这个时候，你的 cookie 并没有带到后端，因为浏览器访问的地址是http://www.example.com，但是请求的接口是http://www.test.com/api/list， 也就说，http://www.test.com/api/这里的 cookie 写入，肯定是在.test.com这个域名下的，而由于当前访问的域名是.example.com，这个时候 cookie 就没有办法带过去 只有请求这种地址的跨域是可以的http://api.example.com/list","categories":[{"name":"大前端","slug":"大前端","permalink":"https://topthinking.gitee.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://topthinking.gitee.io/tags/web/"}]},{"title":"go语言实现递归，扁平转为树形，同时添加层级标识","slug":"go/递归整理树形结构","date":"2020-11-25T13:58:41.790Z","updated":"2021-05-25T15:55:11.903Z","comments":true,"path":"2020/11/25/go/递归整理树形结构/","link":"","permalink":"https://topthinking.gitee.io/2020/11/25/go/%E9%80%92%E5%BD%92%E6%95%B4%E7%90%86%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/","excerpt":"","text":"原始数据结构12345678910111213141516171819202122232425262728293031323334[ &#123; &quot;id&quot;: &quot;1&quot;, &quot;pid&quot;: &quot;0&quot; &#125;, &#123; &quot;id&quot;: &quot;2&quot;, &quot;pid&quot;: &quot;1&quot; &#125;, &#123; &quot;id&quot;: &quot;3&quot;, &quot;pid&quot;: &quot;1&quot; &#125;, &#123; &quot;id&quot;: &quot;4&quot;, &quot;pid&quot;: &quot;0&quot; &#125;, &#123; &quot;id&quot;: &quot;5&quot;, &quot;pid&quot;: &quot;4&quot; &#125;, &#123; &quot;id&quot;: &quot;6&quot;, &quot;pid&quot;: &quot;4&quot; &#125;, &#123; &quot;id&quot;: &quot;7&quot;, &quot;pid&quot;: &quot;3&quot; &#125;, &#123; &quot;id&quot;: &quot;8&quot;, &quot;pid&quot;: &quot;3&quot; &#125;] 目标数据结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[ &#123; &quot;id&quot;: &quot;1&quot;, &quot;pid&quot;: &quot;0&quot;, &quot;level&quot;: 0, &quot;children&quot;: [ &#123; &quot;id&quot;: &quot;2&quot;, &quot;pid&quot;: &quot;1&quot;, &quot;level&quot;: 1 &#125;, &#123; &quot;id&quot;: &quot;3&quot;, &quot;pid&quot;: &quot;1&quot;, &quot;level&quot;: 1, &quot;children&quot;: [ &#123; &quot;id&quot;: &quot;7&quot;, &quot;pid&quot;: &quot;3&quot;, &quot;level&quot;: 2 &#125;, &#123; &quot;id&quot;: &quot;8&quot;, &quot;pid&quot;: &quot;3&quot;, &quot;level&quot;: 2 &#125; ] &#125; ] &#125;, &#123; &quot;id&quot;: &quot;4&quot;, &quot;pid&quot;: &quot;0&quot;, &quot;level&quot;: 0, &quot;children&quot;: [ &#123; &quot;id&quot;: &quot;5&quot;, &quot;pid&quot;: &quot;4&quot;, &quot;level&quot;: 1 &#125;, &#123; &quot;id&quot;: &quot;6&quot;, &quot;pid&quot;: &quot;4&quot;, &quot;level&quot;: 1 &#125; ] &#125;] go 实现的核心函数 指定pid根节点和level根层标识 12345678910111213141516func handle(pid string, level int8) []d &#123; var tree []d for _, v := range data &#123; if v.Pid == pid &#123; var children []d children = append(children, handle(v.ID, level+1)...) tree = append(tree, d&#123; Level: level, ID: v.ID, Pid: v.Pid, Children: children, &#125;) &#125; &#125; return tree&#125; 完整代码，粘贴即可运行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package mainimport ( &quot;bytes&quot; &quot;encoding/json&quot; &quot;log&quot; &quot;os&quot;)type dataSource struct &#123; ID string `json:&quot;id&quot;` Pid string `json:&quot;pid&quot;`&#125;type d struct &#123; Level int8 `json:&quot;level&quot;` ID string `json:&quot;id&quot;` Pid string `json:&quot;pid&quot;` Children []d `json:&quot;children&quot;`&#125;var data = []*dataSource&#123; &#123; ID: &quot;1&quot;, Pid: &quot;0&quot;, &#125;, &#123; ID: &quot;2&quot;, Pid: &quot;1&quot;, &#125;, &#123; ID: &quot;3&quot;, Pid: &quot;1&quot;, &#125;, &#123; ID: &quot;4&quot;, Pid: &quot;0&quot;, &#125;, &#123; ID: &quot;5&quot;, Pid: &quot;4&quot;, &#125;, &#123; ID: &quot;6&quot;, Pid: &quot;4&quot;, &#125;, &#123; ID: &quot;7&quot;, Pid: &quot;3&quot;, &#125;, &#123; ID: &quot;8&quot;, Pid: &quot;3&quot;, &#125;,&#125;func handle(pid string, level int8) []d &#123; var tree []d for _, v := range data &#123; if v.Pid == pid &#123; var children []d children = append(children, handle(v.ID, level+1)...) tree = append(tree, d&#123; Level: level, ID: v.ID, Pid: v.Pid, Children: children, &#125;) &#125; &#125; return tree&#125;func main() &#123; root := handle(&quot;0&quot;, 0) b, _ := json.Marshal(root) var out bytes.Buffer err := json.Indent(&amp;out, b, &quot;&quot;, &quot;\\t&quot;) if err != nil &#123; log.Fatalln(err) &#125; out.WriteTo(os.Stdout)&#125; 输出结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[ &#123; &quot;level&quot;: 0, &quot;id&quot;: &quot;1&quot;, &quot;pid&quot;: &quot;0&quot;, &quot;children&quot;: [ &#123; &quot;level&quot;: 1, &quot;id&quot;: &quot;2&quot;, &quot;pid&quot;: &quot;1&quot;, &quot;children&quot;: null &#125;, &#123; &quot;level&quot;: 1, &quot;id&quot;: &quot;3&quot;, &quot;pid&quot;: &quot;1&quot;, &quot;children&quot;: [ &#123; &quot;level&quot;: 2, &quot;id&quot;: &quot;7&quot;, &quot;pid&quot;: &quot;3&quot;, &quot;children&quot;: null &#125;, &#123; &quot;level&quot;: 2, &quot;id&quot;: &quot;8&quot;, &quot;pid&quot;: &quot;3&quot;, &quot;children&quot;: null &#125; ] &#125; ] &#125;, &#123; &quot;level&quot;: 0, &quot;id&quot;: &quot;4&quot;, &quot;pid&quot;: &quot;0&quot;, &quot;children&quot;: [ &#123; &quot;level&quot;: 1, &quot;id&quot;: &quot;5&quot;, &quot;pid&quot;: &quot;4&quot;, &quot;children&quot;: null &#125;, &#123; &quot;level&quot;: 1, &quot;id&quot;: &quot;6&quot;, &quot;pid&quot;: &quot;4&quot;, &quot;children&quot;: null &#125; ] &#125;]","categories":[{"name":"服务端","slug":"服务端","permalink":"https://topthinking.gitee.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://topthinking.gitee.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"算法","slug":"算法","permalink":"https://topthinking.gitee.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"go","slug":"go","permalink":"https://topthinking.gitee.io/tags/go/"}]},{"title":"go实现类似Promise.all的功能","slug":"go/promise.all","date":"2020-11-21T15:39:29.618Z","updated":"2021-05-25T15:55:39.193Z","comments":true,"path":"2020/11/21/go/promise.all/","link":"","permalink":"https://topthinking.gitee.io/2020/11/21/go/promise.all/","excerpt":"","text":"主要用来加深对于goroutine和channel的理解吧 什么是Promise.all Promise.all 可以将多个 Promise 实例包装成一个新的 Promise 实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被 reject 失败状态的值 javascript123456// run1和run2函数都返回promisePromise.all([run1(), run2()]).then((res) =&gt; &#123; // res的数据是个数组 const [run1Res, run2Res] = res; console.log(run1Res, run2Res);&#125;); go 需要用到协程 goroutine和通道 channel 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport ( &quot;fmt&quot; &quot;sort&quot; &quot;time&quot;)func main() &#123; start := time.Now().Unix() out1 := run1(1, 2, 0, -1, 92, 22, 33, 82, 11) out2 := run2(1, 2, 0, -1, 92, 22, 33, 82, 11) res1 := []int&#123;&#125; res2 := []int&#123;&#125; for v := range out1 &#123; res1 = append(res1, v) &#125; for v := range out2 &#123; res2 = append(res2, v) &#125; // 这里的耗时是4秒，而不是6秒 // 即同时执行，多协程抢占式进行任务 fmt.Println(res1, res2) fmt.Println(&quot;耗时：&quot;, time.Now().Unix()-start, &quot; 秒&quot;)&#125;func run1(a ...int) &lt;-chan int &#123; out := make(chan int) go func() &#123; sort.Ints(a) time.Sleep(time.Second * 4) for _, v := range a &#123; out &lt;- v &#125; close(out) &#125;() return out&#125;func run2(a ...int) &lt;-chan int &#123; out := make(chan int) go func() &#123; sort.Ints(a) time.Sleep(time.Second * 2) for _, v := range a &#123; out &lt;- v &#125; close(out) &#125;() return out&#125; 说明 我们可以将每个run的实现封装为promise.New的函数 上述逻辑，可以再使用promise.All的函数实现 GO 原生支持异步，用不着 promise，这完全是画蛇添足 但是这个主要是想针对多任务并行处理且同时结束的时机控制，加深对于goroutine和channel的理解吧","categories":[{"name":"服务端","slug":"服务端","permalink":"https://topthinking.gitee.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"tags":[{"name":"go","slug":"go","permalink":"https://topthinking.gitee.io/tags/go/"}]},{"title":"加密技术漫谈","slug":"secret","date":"2020-11-17T14:13:03.469Z","updated":"2021-05-25T15:54:22.224Z","comments":true,"path":"2020/11/17/secret/","link":"","permalink":"https://topthinking.gitee.io/2020/11/17/secret/","excerpt":"","text":"这里主要谈两块加密技术的应用 即非对称加密（RSA）和对称加密（AES） 我们可以将两种加密技术配合使用，可以帮助我们加密传输大文件","categories":[{"name":"安全","slug":"安全","permalink":"https://topthinking.gitee.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web","slug":"web","permalink":"https://topthinking.gitee.io/tags/web/"}]},{"title":"职业闲谈","slug":"my/top","date":"2020-08-11T15:48:15.296Z","updated":"2021-05-25T15:57:56.579Z","comments":true,"path":"2020/08/11/my/top/","link":"","permalink":"https://topthinking.gitee.io/2020/08/11/my/top/","excerpt":"","text":"硬实力 数据结构和算法（leetcode） 设计模式 前端 MDN 文档 react 源码（diff 算法、调度算法等） nodejs 底层执行逻辑（v8） 云技术（docker，k8s，serverless） 3D 技术（VR、AR） webassembly（go、rust 等底层语言） 研究面向 5G 的商用技术 软实力 思考问题的方式，多场景换位思考 商业价值和技术变现 英语","categories":[{"name":"后花园","slug":"后花园","permalink":"https://topthinking.gitee.io/categories/%E5%90%8E%E8%8A%B1%E5%9B%AD/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://topthinking.gitee.io/tags/%E6%9D%82%E8%B0%88/"}]}],"categories":[{"name":"大前端","slug":"大前端","permalink":"https://topthinking.gitee.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"后花园","slug":"后花园","permalink":"https://topthinking.gitee.io/categories/%E5%90%8E%E8%8A%B1%E5%9B%AD/"},{"name":"服务端","slug":"服务端","permalink":"https://topthinking.gitee.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"通用技术","slug":"通用技术","permalink":"https://topthinking.gitee.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"},{"name":"安全","slug":"安全","permalink":"https://topthinking.gitee.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"electron","slug":"electron","permalink":"https://topthinking.gitee.io/tags/electron/"},{"name":"工作","slug":"工作","permalink":"https://topthinking.gitee.io/tags/%E5%B7%A5%E4%BD%9C/"},{"name":"webpack","slug":"webpack","permalink":"https://topthinking.gitee.io/tags/webpack/"},{"name":"web","slug":"web","permalink":"https://topthinking.gitee.io/tags/web/"},{"name":"go","slug":"go","permalink":"https://topthinking.gitee.io/tags/go/"},{"name":"mongo","slug":"mongo","permalink":"https://topthinking.gitee.io/tags/mongo/"},{"name":"投资","slug":"投资","permalink":"https://topthinking.gitee.io/tags/%E6%8A%95%E8%B5%84/"},{"name":"docker","slug":"docker","permalink":"https://topthinking.gitee.io/tags/docker/"},{"name":"tips","slug":"tips","permalink":"https://topthinking.gitee.io/tags/tips/"},{"name":"后端","slug":"后端","permalink":"https://topthinking.gitee.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"算法","slug":"算法","permalink":"https://topthinking.gitee.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"杂谈","slug":"杂谈","permalink":"https://topthinking.gitee.io/tags/%E6%9D%82%E8%B0%88/"}]}