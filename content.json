{"meta":{"title":"Topthinking","subtitle":"","description":"你也许什么都没有错，只是老了","author":"topthinking","url":"https://topthinking.gitee.io","root":"/"},"pages":[{"title":"分类","date":"2017-11-30T16:00:00.000Z","updated":"2020-10-30T15:36:19.310Z","comments":true,"path":"categories/index.html","permalink":"https://topthinking.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"Tagcloud","date":"2017-04-26T09:47:43.000Z","updated":"2020-10-30T15:38:04.882Z","comments":true,"path":"tags/index.html","permalink":"https://topthinking.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-11-21T15:39:29.648Z","updated":"2020-11-21T15:39:29.648Z","comments":true,"path":"about/index.html","permalink":"https://topthinking.gitee.io/about/index.html","excerpt":"","text":"About Me 程序员 Programming Language: web（html、javaScript、CSS） nodejs php go docker python others 你也许什么都没有错，只是老了"}],"posts":[{"title":"go语言实现递归，扁平转为树形，同时添加层级标识","slug":"go/递归整理树形结构","date":"2020-11-25T13:58:41.790Z","updated":"2020-11-26T01:26:17.147Z","comments":true,"path":"2020/11/25/go/递归整理树形结构/","link":"","permalink":"https://topthinking.gitee.io/2020/11/25/go/%E9%80%92%E5%BD%92%E6%95%B4%E7%90%86%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/","excerpt":"","text":"原始数据结构12345678910111213141516171819202122232425262728293031323334[ &#123; &quot;id&quot;:&quot;1&quot;, &quot;pid&quot;:&quot;0&quot; &#125;, &#123; &quot;id&quot;:&quot;2&quot;, &quot;pid&quot;:&quot;1&quot; &#125;, &#123; &quot;id&quot;:&quot;3&quot;, &quot;pid&quot;:&quot;1&quot; &#125;, &#123; &quot;id&quot;:&quot;4&quot;, &quot;pid&quot;:&quot;0&quot; &#125;, &#123; &quot;id&quot;:&quot;5&quot;, &quot;pid&quot;:&quot;4&quot; &#125;, &#123; &quot;id&quot;:&quot;6&quot;, &quot;pid&quot;:&quot;4&quot; &#125;, &#123; &quot;id&quot;: &quot;7&quot;, &quot;pid&quot;: &quot;3&quot;, &#125;, &#123; &quot;id&quot;: &quot;8&quot;, &quot;pid&quot;: &quot;3&quot;, &#125;,] 目标数据结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[ &#123; &quot;id&quot;:&quot;1&quot;, &quot;pid&quot;:&quot;0&quot;, &quot;level&quot;: 0, &quot;children&quot;:[ &#123; &quot;id&quot;:&quot;2&quot;, &quot;pid&quot;:&quot;1&quot;, &quot;level&quot;: 1, &#125;, &#123; &quot;id&quot;:&quot;3&quot;, &quot;pid&quot;:&quot;1&quot;, &quot;level&quot;: 1, &quot;children&quot;:[ &#123; &quot;id&quot;:&quot;7&quot;, &quot;pid&quot;:&quot;3&quot;, &quot;level&quot;: 2, &#125;, &#123; &quot;id&quot;:&quot;8&quot;, &quot;pid&quot;:&quot;3&quot;, &quot;level&quot;: 2, &#125;, ] &#125;, ] &#125;, &#123; &quot;id&quot;:&quot;4&quot;, &quot;pid&quot;:&quot;0&quot;, &quot;level&quot;: 0, &quot;children&quot;:[ &#123; &quot;id&quot;:&quot;5&quot;, &quot;pid&quot;:&quot;4&quot;, &quot;level&quot;: 1, &#125;, &#123; &quot;id&quot;:&quot;6&quot;, &quot;pid&quot;:&quot;4&quot;, &quot;level&quot;: 1, &#125;, ] &#125;] go实现的核心函数 指定pid根节点和level根层标识 12345678910111213141516func handle(pid string, level int8) []d &#123; var tree []d for _, v := range data &#123; if v.Pid == pid &#123; var children []d children = append(children, handle(v.ID, level+1)...) tree = append(tree, d&#123; Level: level, ID: v.ID, Pid: v.Pid, Children: children, &#125;) &#125; &#125; return tree&#125; 完整代码，粘贴即可运行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package mainimport ( &quot;bytes&quot; &quot;encoding/json&quot; &quot;log&quot; &quot;os&quot;)type dataSource struct &#123; ID string `json:&quot;id&quot;` Pid string `json:&quot;pid&quot;`&#125;type d struct &#123; Level int8 `json:&quot;level&quot;` ID string `json:&quot;id&quot;` Pid string `json:&quot;pid&quot;` Children []d `json:&quot;children&quot;`&#125;var data = []*dataSource&#123; &#123; ID: &quot;1&quot;, Pid: &quot;0&quot;, &#125;, &#123; ID: &quot;2&quot;, Pid: &quot;1&quot;, &#125;, &#123; ID: &quot;3&quot;, Pid: &quot;1&quot;, &#125;, &#123; ID: &quot;4&quot;, Pid: &quot;0&quot;, &#125;, &#123; ID: &quot;5&quot;, Pid: &quot;4&quot;, &#125;, &#123; ID: &quot;6&quot;, Pid: &quot;4&quot;, &#125;, &#123; ID: &quot;7&quot;, Pid: &quot;3&quot;, &#125;, &#123; ID: &quot;8&quot;, Pid: &quot;3&quot;, &#125;,&#125;func handle(pid string, level int8) []d &#123; var tree []d for _, v := range data &#123; if v.Pid == pid &#123; var children []d children = append(children, handle(v.ID, level+1)...) tree = append(tree, d&#123; Level: level, ID: v.ID, Pid: v.Pid, Children: children, &#125;) &#125; &#125; return tree&#125;func main() &#123; root := handle(&quot;0&quot;, 0) b, _ := json.Marshal(root) var out bytes.Buffer err := json.Indent(&amp;out, b, &quot;&quot;, &quot;\\t&quot;) if err != nil &#123; log.Fatalln(err) &#125; out.WriteTo(os.Stdout)&#125; 输出结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[ &#123; &quot;level&quot;: 0, &quot;id&quot;: &quot;1&quot;, &quot;pid&quot;: &quot;0&quot;, &quot;children&quot;: [ &#123; &quot;level&quot;: 1, &quot;id&quot;: &quot;2&quot;, &quot;pid&quot;: &quot;1&quot;, &quot;children&quot;: null &#125;, &#123; &quot;level&quot;: 1, &quot;id&quot;: &quot;3&quot;, &quot;pid&quot;: &quot;1&quot;, &quot;children&quot;: [ &#123; &quot;level&quot;: 2, &quot;id&quot;: &quot;7&quot;, &quot;pid&quot;: &quot;3&quot;, &quot;children&quot;: null &#125;, &#123; &quot;level&quot;: 2, &quot;id&quot;: &quot;8&quot;, &quot;pid&quot;: &quot;3&quot;, &quot;children&quot;: null &#125; ] &#125; ] &#125;, &#123; &quot;level&quot;: 0, &quot;id&quot;: &quot;4&quot;, &quot;pid&quot;: &quot;0&quot;, &quot;children&quot;: [ &#123; &quot;level&quot;: 1, &quot;id&quot;: &quot;5&quot;, &quot;pid&quot;: &quot;4&quot;, &quot;children&quot;: null &#125;, &#123; &quot;level&quot;: 1, &quot;id&quot;: &quot;6&quot;, &quot;pid&quot;: &quot;4&quot;, &quot;children&quot;: null &#125; ] &#125;]","categories":[{"name":"go","slug":"go","permalink":"https://topthinking.gitee.io/categories/go/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://topthinking.gitee.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"递归","slug":"递归","permalink":"https://topthinking.gitee.io/tags/%E9%80%92%E5%BD%92/"},{"name":"算法","slug":"算法","permalink":"https://topthinking.gitee.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"go实现类似Promise.all的功能","slug":"go/promise.all","date":"2020-11-21T15:39:29.618Z","updated":"2020-11-21T15:39:29.619Z","comments":true,"path":"2020/11/21/go/promise.all/","link":"","permalink":"https://topthinking.gitee.io/2020/11/21/go/promise.all/","excerpt":"","text":"主要用来加深对于goroutine和channel的理解吧 什么是Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值 javascript123456789// run1和run2函数都返回promisePromise.all([ run1(), run2()]).then(res=&gt;&#123; // res的数据是个数组 const [run1Res,run2Res] = res; console.log(run1Res,run2Res);&#125;); go 需要用到协程 goroutine和通道 channel 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport ( &quot;fmt&quot; &quot;sort&quot; &quot;time&quot;)func main() &#123; start := time.Now().Unix() out1 := run1(1, 2, 0, -1, 92, 22, 33, 82, 11) out2 := run2(1, 2, 0, -1, 92, 22, 33, 82, 11) res1 := []int&#123;&#125; res2 := []int&#123;&#125; for v := range out1 &#123; res1 = append(res1, v) &#125; for v := range out2 &#123; res2 = append(res2, v) &#125; // 这里的耗时是4秒，而不是6秒 // 即同时执行，多协程抢占式进行任务 fmt.Println(res1, res2) fmt.Println(&quot;耗时：&quot;, time.Now().Unix()-start, &quot; 秒&quot;)&#125;func run1(a ...int) &lt;-chan int &#123; out := make(chan int) go func() &#123; sort.Ints(a) time.Sleep(time.Second * 4) for _, v := range a &#123; out &lt;- v &#125; close(out) &#125;() return out&#125;func run2(a ...int) &lt;-chan int &#123; out := make(chan int) go func() &#123; sort.Ints(a) time.Sleep(time.Second * 2) for _, v := range a &#123; out &lt;- v &#125; close(out) &#125;() return out&#125; 说明 我们可以将每个run的实现封装为promise.New的函数 上述逻辑，可以再使用promise.All的函数实现 GO原生支持异步，用不着promise，这完全是画蛇添足 但是这个主要是想针对多任务并行处理且同时结束的时机控制，加深对于goroutine和channel的理解吧","categories":[{"name":"go","slug":"go","permalink":"https://topthinking.gitee.io/categories/go/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://topthinking.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"dockerfile编写细节","slug":"docker/dockerfile","date":"2020-11-17T14:17:41.419Z","updated":"2020-11-17T15:06:09.103Z","comments":true,"path":"2020/11/17/docker/dockerfile/","link":"","permalink":"https://topthinking.gitee.io/2020/11/17/docker/dockerfile/","excerpt":"","text":"编译 + 部署 通常我们需要在一个指定的目标环境进行代码的编译，比如nodejs12、golang:1.15等环境 那么我们就可以编写 dockerfile 来实现 前提：一个 dockerfile 有且只有一个基础镜像，比如在生产环境运行时，其实不需要大而全的 nodejs 包，只需要一个小而美的即可 12345678910111213141516171819202122232425262728# 使用node:12.19.0镜像编译源代码FROM node:12.19.0 AS buildWORKDIR /codeCOPY . .# 安装依赖，将TS代码编译为ES5代码# 导出到当前目录 distRUN yarnRUN yarn build# 只安装生产环境运行需要的依赖# 比如类似TypeScript、webpack、babel等依赖就不必安装了，减少目标镜像的体积RUN rm -rf node_modulesRUN yarn install --production# 使用最小的node镜像运行node服务FROM node:12.19.0-alpineWORKDIR /code# 拷贝编译后的资源到当前镜像内COPY --from=build /code/dist /code/serverCOPY --from=build /code/node_modules /code/node_modulesCMD [&quot;node&quot;, &quot;server&quot;]","categories":[{"name":"docker","slug":"docker","permalink":"https://topthinking.gitee.io/categories/docker/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://topthinking.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"加密技术漫谈","slug":"secret","date":"2020-11-17T14:13:03.469Z","updated":"2020-11-17T14:14:58.101Z","comments":true,"path":"2020/11/17/secret/","link":"","permalink":"https://topthinking.gitee.io/2020/11/17/secret/","excerpt":"","text":"","categories":[{"name":"安全","slug":"安全","permalink":"https://topthinking.gitee.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://topthinking.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"职业闲谈","slug":"top","date":"2020-08-11T15:48:15.296Z","updated":"2020-11-17T15:08:20.930Z","comments":true,"path":"2020/08/11/top/","link":"","permalink":"https://topthinking.gitee.io/2020/08/11/top/","excerpt":"","text":"硬实力 数据结构和算法（leetcode） 设计模式 前端MDN文档 react源码（diff算法、调度算法等） nodejs底层执行逻辑（v8） 云技术（docker，k8s，serverless） 3D技术（VR、AR） webassembly（go、rust等底层语言） 研究面向5G的商用技术 软实力 思考问题的方式，多场景换位思考 商业价值和技术变现 英语","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://topthinking.gitee.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"职业","slug":"职业","permalink":"https://topthinking.gitee.io/tags/%E8%81%8C%E4%B8%9A/"}]}],"categories":[{"name":"go","slug":"go","permalink":"https://topthinking.gitee.io/categories/go/"},{"name":"docker","slug":"docker","permalink":"https://topthinking.gitee.io/categories/docker/"},{"name":"安全","slug":"安全","permalink":"https://topthinking.gitee.io/categories/%E5%AE%89%E5%85%A8/"},{"name":"杂谈","slug":"杂谈","permalink":"https://topthinking.gitee.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://topthinking.gitee.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"递归","slug":"递归","permalink":"https://topthinking.gitee.io/tags/%E9%80%92%E5%BD%92/"},{"name":"算法","slug":"算法","permalink":"https://topthinking.gitee.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"职业","slug":"职业","permalink":"https://topthinking.gitee.io/tags/%E8%81%8C%E4%B8%9A/"}]}